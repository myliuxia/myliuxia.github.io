<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue 高频面试题 | 个人的博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="刘夏的个人博客">
    <link rel="preload" href="/assets/css/0.styles.b2bcbf0f.css" as="style"><link rel="preload" href="/assets/js/app.61c6fabb.js" as="script"><link rel="preload" href="/assets/js/3.9f5480b8.js" as="script"><link rel="preload" href="/assets/js/25.788d04a2.js" as="script"><link rel="preload" href="/assets/js/7.795a4e82.js" as="script"><link rel="prefetch" href="/assets/js/10.2d4ebb06.js"><link rel="prefetch" href="/assets/js/11.67c2c25e.js"><link rel="prefetch" href="/assets/js/12.760e412a.js"><link rel="prefetch" href="/assets/js/13.c9016c74.js"><link rel="prefetch" href="/assets/js/14.953cac88.js"><link rel="prefetch" href="/assets/js/15.3d5a8940.js"><link rel="prefetch" href="/assets/js/16.e7e70e6c.js"><link rel="prefetch" href="/assets/js/17.be0a4bfc.js"><link rel="prefetch" href="/assets/js/18.2330b269.js"><link rel="prefetch" href="/assets/js/19.ec5fe80e.js"><link rel="prefetch" href="/assets/js/20.d1bc18e4.js"><link rel="prefetch" href="/assets/js/21.5de2fed3.js"><link rel="prefetch" href="/assets/js/22.ff182f6b.js"><link rel="prefetch" href="/assets/js/23.bd68afd2.js"><link rel="prefetch" href="/assets/js/24.5894c309.js"><link rel="prefetch" href="/assets/js/26.b845a3ff.js"><link rel="prefetch" href="/assets/js/27.3a1f53c2.js"><link rel="prefetch" href="/assets/js/28.666436c9.js"><link rel="prefetch" href="/assets/js/29.a1693985.js"><link rel="prefetch" href="/assets/js/30.f20ffd28.js"><link rel="prefetch" href="/assets/js/31.562b6208.js"><link rel="prefetch" href="/assets/js/32.1775271a.js"><link rel="prefetch" href="/assets/js/33.1e304896.js"><link rel="prefetch" href="/assets/js/4.f58d7f67.js"><link rel="prefetch" href="/assets/js/5.f80973b8.js"><link rel="prefetch" href="/assets/js/6.e5d08169.js"><link rel="prefetch" href="/assets/js/8.0aa59495.js"><link rel="prefetch" href="/assets/js/9.312aa46c.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.1a4ac135.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b2bcbf0f.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="header-wrapper"><div class="header-content"><a href="/" class="left router-link-active"><div class="logo-image"><img src="/avatar.png" alt="个人的博客"></div> <span class="logo-title">个人的博客</span></a> <div class="right"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <div><nav class="pc-nav-links"><div class="nav-item"><span exact="true" class="nav-link">首页</span></div><div class="nav-item"><span class="nav-link">分类</span></div><div class="nav-item"><span class="nav-link">标签</span></div><div class="nav-item"><span class="nav-link">关于</span></div><div class="nav-item"><span class="nav-link">归档</span></div> <!----></nav> <div class="mobile-nav"><div class="nav-icon"><i class="icon-toc"></i></div></div> <div class="nav-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item"><span exact="true" class="nav-link">首页</span></li><li class="drawer-menu-item"><span class="nav-link">分类</span></li><li class="drawer-menu-item"><span class="nav-link">标签</span></li><li class="drawer-menu-item"><span class="nav-link">关于</span></li><li class="drawer-menu-item"><span class="nav-link">归档</span></li></ul></div> <div class="nav-mask" style="display:none;"></div></div></div></div></header> <div class="theme-main"><div class="theme-main__inner post"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting"><header class="article__header"><h1 itemprop="name headline" class="post-title">
          Vue 高频面试题
        </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><i class="icon-author"></i> <a href="https://github.com/myliuxia" target="_blank">liuxia</a></div> <div class="post-meta__date"><i class="icon-calendar"></i> <time pubdate itemprop="datePublished" datetime="2022-03-09T16:09:16.000Z">
      2022-03-09
    </time></div> <div class="post-meta__cates"><i class="icon-cate"></i> <a href="/categories/技术/">
      技术
    </a></div> <!----></div></header> <div class="article-con"><div itemprop="articleBody" class="article-content content__default"><blockquote><p>汇总vue相关的高频面试题
</p></blockquote> <h2 id="一、vue2-0-响应式原理"><a href="#一、vue2-0-响应式原理" class="header-anchor">#</a> 一、Vue2.0 响应式原理</h2> <p><img src="/image/vue_data.png" alt="图片"></p> <h3 id="核心实现类"><a href="#核心实现类" class="header-anchor">#</a> 核心实现类:</h3> <p>Observer : 它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新</p> <p>Dep : 用于收集当前响应式对象的依赖关系,每个响应式对象包括子对象都拥有一个 Dep 实例（里面 subs 是 Watcher 实例数组）,当数据有变更时,会通过 dep.notify()通知各个 watcher。</p> <p>Watcher : 观察者对象 , 实例分为渲染 watcher (render watcher),计算属性 watcher (computed watcher),侦听器 watcher（user watcher）三种</p> <h3 id="watcher-和-dep-的关系"><a href="#watcher-和-dep-的关系" class="header-anchor">#</a> Watcher 和 Dep 的关系</h3> <p>watcher 中实例化了 dep 并向 dep.subs 中添加了订阅者,dep 通过 notify 遍历了 dep.subs 通知每个 watcher 更新。</p> <h3 id="依赖收集"><a href="#依赖收集" class="header-anchor">#</a> 依赖收集</h3> <ul><li>initState 时,对 computed 属性初始化时,触发 computed watcher 依赖收集</li> <li>initState 时,对侦听属性初始化时,触发 user watcher 依赖收集</li> <li>render()的过程,触发 render watcher 依赖收集</li> <li>re-render 时,vm.render()再次执行,会移除所有 subs 中的 watcer 的订阅,重新赋值。</li></ul> <h3 id="派发更新"><a href="#派发更新" class="header-anchor">#</a> 派发更新</h3> <ul><li>组件中对响应的数据进行了修改,触发 setter 的逻辑</li> <li>调用 dep.notify()</li> <li>遍历所有的 subs（Watcher 实例）,调用每一个 watcher 的 update 方法。</li></ul> <h3 id="原理"><a href="#原理" class="header-anchor">#</a> 原理</h3> <p>当创建 Vue 实例时,vue 会遍历 data 选项的属性,利用 Object.defineProperty 为属性添加 getter 和 setter 对数据的读取进行劫持（getter 用来依赖收集,setter 用来派发更新）,并且在内部追踪依赖,在属性被访问和修改时通知变化。</p> <p>每个组件实例会有相应的 watcher 实例,会在组件渲染的过程中记录依赖的所有数据属性（进行依赖收集,还有 computed watcher,user watcher 实例）,之后依赖项被改动时,setter 方法会通知依赖与此 data 的 watcher 实例重新计算（派发更新）,从而使它关联的组件重新渲染。</p> <p>一句话总结:
vue.js 采用数据劫持结合发布-订阅模式,通过 Object.defineproperty 来劫持各个属性的 setter,getter,在数据变动时发布消息给订阅者,触发响应的监听回调</p> <h2 id="二、vue3-0-怎么实现数据劫持的-为什么弃用defineproperty"><a href="#二、vue3-0-怎么实现数据劫持的-为什么弃用defineproperty" class="header-anchor">#</a> 二、Vue3.0 怎么实现数据劫持的，为什么弃用defineProperty</h2> <p>在vue2.x中是采用Object.defineProperty对数据进行劫持，但对于数组和对象数据的监听上存在一定的局限。</p> <h3 id="vue2-x对于数组的监听"><a href="#vue2-x对于数组的监听" class="header-anchor">#</a> vue2.x对于数组的监听</h3> <p>Object.defineProperty 本身有一定的监控到数组下标变化的能力,但是在 Vue 中,从性能/体验的性价比考虑,尤大大就弃用了这个特性。为了解决这个问题,经过 vue 内部处理后可以使用以下几种方法来监听数组</p> <div class="language- extra-class"><pre class="language-text"><code>push()
pop()
shift()
unshift()
splice()
sort()
reverse()
</code></pre></div><p>由于只针对以上7种方法进行了hack处理，所以其他数组的属性也会检测不到。</p> <p>如官方的原文：由于 JavaScript 的限制， Vue 不能检测以下变动的数组：</p> <blockquote><p>当你利用索引直接设置一个项时，例如： vm.items[indexOfItem] = newValue<br>
当你修改数组的长度时，例如： vm.items.length = newLength</p></blockquote> <h3 id="vue2-x对于对象的监听"><a href="#vue2-x对于对象的监听" class="header-anchor">#</a> vue2.x对于对象的监听</h3> <p>Object.defineProperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。Vue 2.x 里,是通过 递归 + 遍历 data 对象来实现对数据的监控的,如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象是才是更好的选择。</p> <h3 id="vue3-0-采用了proxy对数据进行劫持"><a href="#vue3-0-采用了proxy对数据进行劫持" class="header-anchor">#</a> vue3.0 采用了Proxy对数据进行劫持</h3> <p>因为 Proxy 可以劫持整个对象,并返回一个新的对象。Proxy 不仅可以代理对象,还可以代理数组。还可以代理动态增加的属性。</p> <h2 id="三、vue-是如何对数组方法进行变异的"><a href="#三、vue-是如何对数组方法进行变异的" class="header-anchor">#</a> 三、vue 是如何对数组方法进行变异的 ?</h2> <p>vue源码如下</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// \core\observer\array.js</span>
<span class="token comment">/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> def <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'../util/index'</span>

<span class="token keyword">const</span> arrayProto <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype
<span class="token keyword">export</span> <span class="token keyword">const</span> arrayMethods <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>arrayProto<span class="token punctuation">)</span>

<span class="token keyword">const</span> methodsToPatch <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">'push'</span><span class="token punctuation">,</span>
  <span class="token string">'pop'</span><span class="token punctuation">,</span>
  <span class="token string">'shift'</span><span class="token punctuation">,</span>
  <span class="token string">'unshift'</span><span class="token punctuation">,</span>
  <span class="token string">'splice'</span><span class="token punctuation">,</span>
  <span class="token string">'sort'</span><span class="token punctuation">,</span>
  <span class="token string">'reverse'</span>
<span class="token punctuation">]</span>

<span class="token comment">/**
 * Intercept mutating methods and emit events
 */</span>
methodsToPatch<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">method</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// cache original method</span>
  <span class="token keyword">const</span> original <span class="token operator">=</span> arrayProto<span class="token punctuation">[</span>method<span class="token punctuation">]</span>
  <span class="token function">def</span><span class="token punctuation">(</span>arrayMethods<span class="token punctuation">,</span> method<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">mutator</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">original</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__ob__
    <span class="token keyword">let</span> inserted
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token string">'push'</span><span class="token operator">:</span>
      <span class="token keyword">case</span> <span class="token string">'unshift'</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args
        <span class="token keyword">break</span>
      <span class="token keyword">case</span> <span class="token string">'splice'</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> ob<span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>inserted<span class="token punctuation">)</span>
    <span class="token comment">// notify change</span>
    ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>Vue 通过原型拦截的方式重写了数组的 7 个方法,首先获取到这个数组的ob,也就是它的 Observer 对象,如果有新的值,就调用 observeArray 对新的值进行监听,然后手动调用 notify,通知 render watcher,执行 update</p> <h2 id="四、vue-生命周期及父子组件生命周期钩子函数执行顺序"><a href="#四、vue-生命周期及父子组件生命周期钩子函数执行顺序" class="header-anchor">#</a> 四、Vue 生命周期及父子组件生命周期钩子函数执行顺序</h2> <h3 id="单一组件生命周期钩子函数执行顺序"><a href="#单一组件生命周期钩子函数执行顺序" class="header-anchor">#</a> 单一组件生命周期钩子函数执行顺序</h3> <ul><li>beforeCreate：在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。</li> <li>created：实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</li> <li>beforeMount：在挂载开始之前被调用：相关的 render 函数首次被调用。</li> <li>Mounted: el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</li> <li>beforeUpdate：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</li> <li>updated：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。</li> <li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。</li> <li>destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li></ul> <p>另外Vue的keep-alive组件独有的两个钩子函数：</p> <ul><li>activated：keep-alive 组件激活时调用。</li> <li>deactivated：keep-alive 组件停用时调用。</li></ul> <h3 id="父子组件生命周期钩子函数执行顺序"><a href="#父子组件生命周期钩子函数执行顺序" class="header-anchor">#</a> 父子组件生命周期钩子函数执行顺序</h3> <p>加载渲染过程：</p> <blockquote><p>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</p></blockquote> <p>子组件更新过程:</p> <blockquote><p>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p></blockquote> <p>父组件更新过程:</p> <blockquote><p>父beforeUpdate-&gt;父updated</p></blockquote> <p>销毁过程</p> <blockquote><p>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p></blockquote> <h2 id="五、computed-的实现原理"><a href="#五、computed-的实现原理" class="header-anchor">#</a> 五、computed 的实现原理</h2> <p>computed 本质是一个惰性求值的观察者。</p> <p>computed 内部实现了一个惰性的 watcher,也就是 computed watcher,computed watcher 不会立刻求值,同时持有一个 dep 实例。</p> <p>其内部通过 this.dirty 属性标记计算属性是否需要重新求值。</p> <p>当 computed 的依赖状态发生改变时,就会通知这个惰性的 watcher,</p> <p>computed watcher 通过 this.dep.subs.length 判断有没有订阅者,</p> <p>有的话,会重新计算,然后对比新旧值,如果变化了,会重新渲染。 <strong>(Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化时才会触发渲染 watcher 重新渲染，本质上是一种优化。)</strong></p> <p>没有的话,仅仅把 this.dirty = true。 <strong>(当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备 lazy（懒计算）特性。)</strong></p> <h2 id="六、computed-和-watch-有什么区别及运用场景"><a href="#六、computed-和-watch-有什么区别及运用场景" class="header-anchor">#</a> 六、computed 和 watch 有什么区别及运用场景?</h2> <h3 id="区别"><a href="#区别" class="header-anchor">#</a> 区别</h3> <ul><li><p>computed 计算属性 : 依赖其它属性值,并且 computed 的值有缓存,只有它依赖的属性值发生改变,下一次获取 computed 的值时才会重新计算 computed 的值。</p></li> <li><p>watch 侦听器 : 更多的是「观察」的作用,无缓存性,类似于某些数据的监听回调,每当监听的数据变化时都会执行回调进行后续操作。</p></li></ul> <h3 id="运用场景"><a href="#运用场景" class="header-anchor">#</a> 运用场景</h3> <p>当我们需要进行数值计算,并且依赖于其它数据时,应该使用 computed,因为可以利用 computed 的缓存特性,避免每次获取值时,都要重新计算。</p> <p>当我们需要在数据变化时执行异步或开销较大的操作时,应该使用 watch,使用 watch 选项允许我们执行异步操作 ( 访问一个 API ),限制我们执行该操作的频率,并在我们得到最终结果前,设置中间状态。这些都是计算属性无法做到的。</p> <h2 id="七、vue-中-key-的作用是什么"><a href="#七、vue-中-key-的作用是什么" class="header-anchor">#</a> 七、Vue 中 key 的作用是什么</h2> <p>key 是每个 vnode 的唯一 id,依靠 key,我们的diff操作可以更准确、更快速（对于简单列表页渲染来说 diff 节点也更快,但会产生一些隐藏的副作用,比如可能不会产生过渡效果,或者在某些节点有绑定数据（表单）状态，会出现状态错位。）</p> <p>diff 算法的过程中，先会进行新旧节点的首尾交叉对比，当无法匹配的时候会用新节点的key与旧节点进行对比，从而快速的找到相应节点</p> <p>更准确：因为带 key 就不是就地复用了，在sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更家准确，如果不加key,会导致之前节点的状态被保留下来，会产生一系列的bug。</p> <p>更快速：key的唯一性可以被Map数据结构充分利用，相比于遍历查找的时间复杂度 O(n),Map的时间复杂度仅仅为 O(1).</p> <p>源码如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">createKeyToOldIdx</span> <span class="token punctuation">(</span><span class="token parameter">children<span class="token punctuation">,</span> beginIdx<span class="token punctuation">,</span> endIdx</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> i<span class="token punctuation">,</span> key
  <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> beginIdx<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> endIdx<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    key <span class="token operator">=</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> map<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> i
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> map
<span class="token punctuation">}</span>
</code></pre></div><h2 id="八、vue-组件-data-为什么必须是函数"><a href="#八、vue-组件-data-为什么必须是函数" class="header-anchor">#</a> 八、Vue 组件 data 为什么必须是函数？</h2> <blockquote><p>new Vue()实例中，data 可以直接是一个对象，为什么在 vue 组件中 data 必须是个函数呢？</p></blockquote> <p>应为组件是可以复用的, JS 里对象是引用关系，如果组件 data 是一个对象，那么子组件中的 data 属性会相互污染。</p> <p>所以一个组件的 data 选项必须是一个函数，因此每个组件实例可以维护一份被返回对象的独立的拷贝。new Vue() 的实例是不会被复用的，所以不存在以上问题</p> <h2 id="九、nexttick-的原理"><a href="#九、nexttick-的原理" class="header-anchor">#</a> 九、nextTick 的原理</h2> <blockquote><p>官方文档：
在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p></blockquote> <p>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p> <p>如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。</p> <p>然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。</p> <p>Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。
<strong>在 vue2.5 的源码中，macrotask 降级的方案依次是：setImmediate、MessageChannel、setTimeout</strong></p> <p>vue 的 nextTick 方法的实现原理:</p> <ul><li>vue 用异步队列的方式来控制 DOM 更新和 nextTick 回调先后执行</li> <li>microtask 因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕</li> <li>考虑兼容问题,vue 做了 microtask 向 macrotask 的降级方案</li></ul> <h2 id="十、vm-set-实现原理是什么"><a href="#十、vm-set-实现原理是什么" class="header-anchor">#</a> 十、vm.$set()实现原理是什么?</h2> <p>受现代 JavaScript 的限制 (而且 Object.observe 也已经被废弃)，Vue 无法检测到对象属性的添加或删除。</p> <p>由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</p> <p>对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式属性。</p> <p>那么 Vue 内部是如何解决对象新增属性不能响应的问题的呢?
源码如下：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// src\core\observer\index.js</span>
<span class="token comment">/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token keyword">set</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token operator">|</span> Object<span class="token punctuation">,</span> key<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> val<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">any</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span>
    <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isPrimitive</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Cannot set reactive property on undefined, null, or primitive value: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token punctuation">(</span>target<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// target 为数组</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isValidArrayIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 修改数组的长度, 避免索引&gt;数组长度导致splice()执行有误</span>
    target<span class="token punctuation">.</span>length <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>length<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token comment">// 利用数组的splice变异方法触发响应式</span>
    target<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>  
  <span class="token comment">// target为对象, key在target或者target.prototype上 且必须不能在 Object.prototype 上,直接赋值</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> target <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span> 
  <span class="token comment">// 以上都不成立, 即开始给target创建一个全新的属性</span>
  <span class="token comment">// 获取Observer实例</span>
  <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__ob__
  <span class="token keyword">if</span> <span class="token punctuation">(</span>target<span class="token punctuation">.</span>_isVue <span class="token operator">||</span> <span class="token punctuation">(</span>ob <span class="token operator">&amp;&amp;</span> ob<span class="token punctuation">.</span>vmCount<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span>
      <span class="token string">'Avoid adding reactive properties to a Vue instance or its root $data '</span> <span class="token operator">+</span>
      <span class="token string">'at runtime - declare it upfront in the data option.'</span>
    <span class="token punctuation">)</span>
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token comment">// target 本身就不是响应式数据, 直接赋值</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ob<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
   <span class="token comment">// 进行响应式处理</span>
  <span class="token function">defineReactive</span><span class="token punctuation">(</span>ob<span class="token punctuation">.</span>value<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
  ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> val
<span class="token punctuation">}</span>
</code></pre></div><p>过程：</p> <ul><li>如果目标是数组,使用 vue 实现的变异方法 splice 实现响应式</li> <li>如果目标是对象,判断属性存在,即为响应式,直接赋值</li> <li>如果 target 本身就不是响应式,直接赋值</li> <li>如果属性不是响应式,则调用 defineReactive 方法进行响应式处理</li></ul></div></div> <div class="article-footer"><ul class="post-tag"><li class="post-tag__item"><a href="/tags/vue"><span># vue</span></a></li><li class="post-tag__item"><a href="/tags/面试"><span># 面试</span></a></li></ul> <div class="post-operate"><a href="/pages/d32196/" class="post-operate__prev">BFC (Block Formatting Context)</a> <a href="/pages/489ccc/" class="post-operate__next">WebGL入门 -- 认识WebGL</a></div></div></article></div></div> <svg style="display:none;"><symbol id="theme-icon-auto" viewBox="0 0 32 32"><path d="M16 0c-8.837 0-16 7.163-16 16s7.163 16 16 16 16-7.163 16-16-7.163-16-16-16zM4 16c0-6.627 5.373-12 12-12v24c-6.627 0-12-5.373-12-12z"></path></symbol> <symbol id="theme-icon-sun" viewBox="0 0 32 32"><path d="M16 26c1.105 0 2 0.895 2 2v2c0 1.105-0.895 2-2 2s-2-0.895-2-2v-2c0-1.105 0.895-2 2-2zM16 6c-1.105 0-2-0.895-2-2v-2c0-1.105 0.895-2 2-2s2 0.895 2 2v2c0 1.105-0.895 2-2 2zM30 14c1.105 0 2 0.895 2 2s-0.895 2-2 2h-2c-1.105 0-2-0.895-2-2s0.895-2 2-2h2zM6 16c0 1.105-0.895 2-2 2h-2c-1.105 0-2-0.895-2-2s0.895-2 2-2h2c1.105 0 2 0.895 2 2zM25.899 23.071l1.414 1.414c0.781 0.781 0.781 2.047 0 2.828s-2.047 0.781-2.828 0l-1.414-1.414c-0.781-0.781-0.781-2.047 0-2.828s2.047-0.781 2.828 0zM6.101 8.929l-1.414-1.414c-0.781-0.781-0.781-2.047 0-2.828s2.047-0.781 2.828 0l1.414 1.414c0.781 0.781 0.781 2.047 0 2.828s-2.047 0.781-2.828 0zM25.899 8.929c-0.781 0.781-2.047 0.781-2.828 0s-0.781-2.047 0-2.828l1.414-1.414c0.781-0.781 2.047-0.781 2.828 0s0.781 2.047 0 2.828l-1.414 1.414zM6.101 23.071c0.781-0.781 2.047-0.781 2.828 0s0.781 2.047 0 2.828l-1.414 1.414c-0.781 0.781-2.047 0.781-2.828 0s-0.781-2.047 0-2.828l1.414-1.414z"></path> <path d="M16 8c-4.418 0-8 3.582-8 8s3.582 8 8 8c4.418 0 8-3.582 8-8s-3.582-8-8-8zM16 21c-2.761 0-5-2.239-5-5s2.239-5 5-5 5 2.239 5 5-2.239 5-5 5z"></path></symbol> <symbol id="theme-icon-moon" viewBox="0 0 18 18"><path d="M7.246 3.255c-0.251 0.828-0.322 1.71-0.198 2.597 0.366 2.63 2.455 4.723 5.080 5.089 0.282 0.040 0.568 0.060 0.85 0.060 0.599 0 1.184-0.087 1.742-0.257-0.674 2.215-2.642 3.926-4.973 4.21-0.254 0.031-0.51 0.047-0.762 0.047-1.713 0-3.349-0.738-4.486-2.024-1.152-1.304-1.669-2.987-1.457-4.739 0.284-2.335 1.992-4.307 4.204-4.982zM8.985 1c-0.362 0-0.731 0.024-1.104 0.075-3.543 0.48-6.388 3.364-6.82 6.92-0.592 4.867 3.184 9.005 7.924 9.005 0.33 0 0.665-0.020 1.003-0.062 3.549-0.433 6.428-3.283 6.907-6.833 0.052-0.383 0.076-0.761 0.075-1.134-0.002-0.583-0.482-0.972-0.996-0.972-0.209 0-0.424 0.065-0.614 0.207-0.665 0.498-1.489 0.793-2.383 0.793-0.188 0-0.38-0.013-0.574-0.040-1.732-0.242-3.137-1.649-3.378-3.385-0.155-1.115 0.149-2.156 0.751-2.963 0.415-0.657 0.025-1.609-0.764-1.612-0.009 0-0.018 0-0.028 0v0z"></path></symbol> <symbol id="theme-icon-palette" viewBox="0 0 1024 1024"><path d="M745.984 512q25.984 0 45.013333-18.005333t18.986667-45.994667-18.986667-45.994667-45.013333-18.005333-45.013333 18.005333-18.986667 45.994667 18.986667 45.994667 45.013333 18.005333zM617.984 342.016q25.984 0 45.013333-18.986667t18.986667-45.013333-18.986667-45.013333-45.013333-18.986667-45.013333 18.986667-18.986667 45.013333 18.986667 45.013333 45.013333 18.986667zM406.016 342.016q25.984 0 45.013333-18.986667t18.986667-45.013333-18.986667-45.013333-45.013333-18.986667-45.013333 18.986667-18.986667 45.013333 18.986667 45.013333 45.013333 18.986667zM278.016 512q25.984 0 45.013333-18.005333t18.986667-45.994667-18.986667-45.994667-45.013333-18.005333-45.013333 18.005333-18.986667 45.994667 18.986667 45.994667 45.013333 18.005333zM512 128q157.994667 0 271.018667 100.010667t112.981333 242.005333q0 88.021333-63.018667 150.016t-150.997333 61.994667l-73.984 0q-27.989333 0-45.994667 18.986667t-18.005333 45.013333q0 22.016 16 41.984t16 43.989333q0 27.989333-18.005333 45.994667t-45.994667 18.005333q-160 0-272-112t-112-272 112-272 272-112z" p-id="10529"></path></symbol> </svg></div><div class="global-ui"><div class="float-menu-wrap"><!----> <div class="float-menu__list"><span class="icon-up"></span> <span class="theme-mode-setting"><svg class="theme-icon theme-icon-sun"><use xlink:href="#theme-icon-sun"></use></svg></span> <!----> <span class="icon-toc"></span> <span class="icon-search"></span></div> <div class="float-menu"><svg width="100%" height="100%" class="float-menu__progress"><circle stroke-dasharray="0% 301.59289474462014%" stroke="currentcolor" stroke-width="2%" fill="none" r="48%" cx="50%" cy="50%"></circle></svg> <div class="float-menu__dot"></div></div></div><div class="theme-search" style="display:none;"><div class="theme-search__inner"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <a class="icon-exit"></a></div></div></div></div>
    <script src="/assets/js/app.61c6fabb.js" defer></script><script src="/assets/js/3.9f5480b8.js" defer></script><script src="/assets/js/25.788d04a2.js" defer></script><script src="/assets/js/7.795a4e82.js" defer></script>
  </body>
</html>